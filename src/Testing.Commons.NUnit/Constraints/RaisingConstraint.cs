using System;
using System.Linq.Expressions;
using NUnit.Framework;
using NUnit.Framework.Constraints;

namespace Testing.Commons.NUnit.Constraints
{
	/// <summary>
	/// Base class for constraints for event raising types.
	/// </summary>
	/// <typeparam name="TSubject">Type that raises the event.</typeparam>
	/// <typeparam name="TEventArgs">The type of the event data generated by the event.</typeparam>
	public abstract class RaisingConstraint<TSubject, TEventArgs> : Constraint where TEventArgs : EventArgs
	{
		/// <summary>
		/// Instance of the event raising type.
		/// </summary>
		protected TSubject Subject { get; private set; }
		private readonly Constraint _matchingPropertyName;
		private bool _eventRaised;

		/// <summary>
		/// Return value of <see cref="Constraint.Matches(ActualValueDelegate)"/>.
		/// </summary>
		protected bool Matched { get; private set; }

		/// <summary>
		/// Name of the event.
		/// </summary>
		protected abstract string EventName { get; }

		/// <summary>
		/// Instantiate the constraint
		/// </summary>
		/// <param name="subject"> Instance of the event raising type.</param>
		/// <param name="property">Expression that represents the name of a property.</param>
		/// <param name="eventArgs">Constraint on the property name.</param>
		protected RaisingConstraint(TSubject subject, Expression<Func<TSubject, object>> property, Func<Constraint, LambdaPropertyConstraint<TEventArgs>> eventArgs)
		{
			Subject = subject;
			_matchingPropertyName = eventArgs(Is.EqualTo(Name.Of(property)));
		}

		/// <summary>
		/// Instantiate the constraint
		/// </summary>
		/// <param name="subject"> Instance of the event raising type.</param>
		/// <param name="eventArgsConstraint">Constraint to be applied to the event arg property.</param>
		/// <param name="eventArgs">Constraint on the property name.</param>
		protected RaisingConstraint(TSubject subject, Constraint eventArgsConstraint, Func<Constraint, LambdaPropertyConstraint<TEventArgs>> eventArgs)
		{
			Subject = subject;
			_matchingPropertyName = eventArgs(eventArgsConstraint);
		}

		/// <summary>
		/// To be executed inside the callback of the event.
		/// </summary>
		/// <param name="e">The event data generated by the event.</param>
		protected void OnEventRaised(TEventArgs e)
		{
			_eventRaised = true;
			Matched = _matchingPropertyName.Matches(e);
		}

		/// <summary>
		/// Test whether the constraint is satisfied by a given value.
		/// </summary>
		/// <param name="current">The value to be tested</param>
		/// <returns>True for success, false for failure</returns>
		public override bool Matches(object current)
		{
			return Matched;
		}

		/// <summary>
		/// Write the constraint description to a MessageWriter.
		/// </summary>
		/// <param name="writer">The writer on which the description is displayed.</param>
		public override void WriteDescriptionTo(MessageWriter writer)
		{
			writer.Write(string.Format("raise event '{0}' and ", EventName));
			_matchingPropertyName.WriteDescriptionTo(writer);
		}

		/// <summary>
		/// Write the actual value for a failing constraint test to a
		/// MessageWriter. The default implementation simply writes
		/// the raw value of actual, leaving it to the writer to
		/// perform any formatting.
		/// </summary>
		/// <param name="writer">The writer on which the actual value is displayed</param>
		public override void WriteActualValueTo(MessageWriter writer)
		{
			if (!_eventRaised)
			{
				writer.Write(string.Format("event '{0}' not raised", EventName));
			}
			else
			{
				_matchingPropertyName.WriteActualValueTo(writer);
			}
		}
	}
}