using System;
using System.Linq.Expressions;
using NUnit.Framework;
using NUnit.Framework.Constraints;

namespace Testing.Commons.NUnit.Constraints
{
	/// <summary>
	/// Base class for constraints for event raising types.
	/// </summary>
	/// <typeparam name="TSubject">Type that raises the event.</typeparam>
	/// <typeparam name="TEventArgs">The type of the event data generated by the event.</typeparam>
	public abstract class RaisingConstraint<TSubject, TEventArgs> : Constraint where TEventArgs : EventArgs
	{
		/// <summary>
		/// Instance of the event raising type.
		/// </summary>
		protected TSubject Subject { get; }
		private readonly Constraint _matchingPropertyName;
		private bool _eventRaised;

		/// <summary>
		/// Return value of <see cref="Constraint.ApplyTo{TActual}(ActualValueDelegate{TActual})"/>.
		/// </summary>
		protected ConstraintResult Matched { get; private set; }

		/// <summary>
		/// Name of the event.
		/// </summary>
		protected abstract string EventName { get; }

		/// <summary>
		/// Instantiate the constraint
		/// </summary>
		/// <param name="subject"> Instance of the event raising type.</param>
		/// <param name="property">Expression that represents the name of a property.</param>
		/// <param name="eventArgs">Constraint on the property name.</param>
		protected RaisingConstraint(TSubject subject, string property, Func<Constraint, ComposablePropertyConstraint> eventArgs)
		{
			Subject = subject;
			_matchingPropertyName = eventArgs(Is.EqualTo(property));
			// failing is no event raised
			Matched = new ConstraintResult(this, null, false);
		}

		/// <summary>
		/// Instantiate the constraint
		/// </summary>
		/// <param name="subject"> Instance of the event raising type.</param>
		/// <param name="property">Expression that represents the name of a property.</param>
		/// <param name="eventArgs">Constraint on the property name.</param>
		protected RaisingConstraint(TSubject subject, Expression<Func<TSubject, object>> property, Func<Constraint, ComposablePropertyConstraint> eventArgs) : this(subject, Name.Of(property), eventArgs) { }

		/// <summary>
		/// Instantiate the constraint
		/// </summary>
		/// <param name="subject"> Instance of the event raising type.</param>
		/// <param name="eventArgsConstraint">Constraint to be applied to the event arg property.</param>
		/// <param name="eventArgs">Constraint on the property name.</param>
		protected RaisingConstraint(TSubject subject, Constraint eventArgsConstraint, Func<Constraint, ComposablePropertyConstraint> eventArgs)
		{
			Subject = subject;
			_matchingPropertyName = eventArgs(eventArgsConstraint);
			// failing is no event raised
			Matched = new ConstraintResult(this, null, false);
		}

		/// <summary>
		/// To be executed inside the callback of the event.
		/// </summary>
		/// <param name="e">The event data generated by the event.</param>
		protected void onEventRaised(TEventArgs e)
		{
			_eventRaised = true;
			Matched = new RaisingResult(_eventRaised, EventName,_matchingPropertyName, _matchingPropertyName.ApplyTo(e));
		}

		public override ConstraintResult ApplyTo<TActual>(TActual actual)
		{
			return new RaisingResult(_eventRaised, EventName, this, Matched);
		}

		public override string Description => $"raise event '{EventName}' and {_matchingPropertyName.Description}";

		protected ConstraintResult result()
		{
			return new RaisingResult(_eventRaised, EventName, this, Matched);
		}

		class RaisingResult : ConstraintResult
		{
			private readonly bool _eventRaised;
			private readonly string _eventName;

			public RaisingResult(bool eventRaised, string eventName, IConstraint matchingPropertyName, ConstraintResult result) : base(matchingPropertyName, result.ActualValue, result.IsSuccess)
			{
				_eventRaised = eventRaised;
				_eventName = eventName;
			}

			public override void WriteActualValueTo(MessageWriter writer)
			{
				if (!_eventRaised)
				{
					writer.Write("event '{0}' not raised", _eventName);
				}
				else
				{
					writer.WriteActualValue(ActualValue);
				}
			}
		}
	}
}